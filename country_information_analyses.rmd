---
title: "Automated Subtitling Market Segmentation"
author: "Ryan Lord"
date: "2025-03-17"
output: html_document
---



```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

This notebook shows how I processed and visualised data from the country_information.csv that was created 

Check if required packages are installed and install if necessary. 
Add packages to library. 
```{r,warning=FALSE,message=FALSE}
if (!requireNamespace("ggplot2", quietly = TRUE)) {
  install.packages("ggplot2")
}
if (!requireNamespace("tidyverse", quietly = TRUE)) {
  install.packages("tidyverse")
}
if (!requireNamespace("readr", quietly = TRUE)) {
  install.packages("readr")
}
if (!requireNamespace("treemapify", quietly = TRUE)) {
  install.packages("treemapify")
}
if (!requireNamespace("DT", quietly = TRUE)) {
  install.packages("DT")
}

library(ggplot2)    # data visualisation
library(tidyverse)  # data wrangling
library(readr)      # import .csv from github
library(treemapify) # create tree maps
library(DT)         # nicely formatted tables
library(htmltools)  # additional descriptions added to datatables


```



Import data from our github repo: https://github.com/NHS-Ryan/windmill_mov_subtitles
Some small data cleaning required to account for NULL values in the country_information.csv file
```{r, warning=FALSE}
country_information <- read_csv("https://raw.githubusercontent.com/NHS-Ryan/windmill_mov_subtitles/refs/heads/main/country_information.csv")
supported_languages <- read_csv("https://raw.githubusercontent.com/NHS-Ryan/windmill_mov_subtitles/refs/heads/main/supported_languages.csv")
netflix_restricted_countries <- read_csv("https://raw.githubusercontent.com/NHS-Ryan/windmill_mov_subtitles/refs/heads/main/netflix_restricted_countries.csv")

head(country_information)
head(supported_languages)
head(netflix_restricted_countries)

```



Join to Windmill Pictures' Supported Languages information so we can exclude countries with languages we are already working with. 
```{r}

supported_languages$supported_language_flag = 0
netflix_restricted_countries$netflix_restricted_countries_flag = 0

country_information <- left_join(country_information, supported_languages, 
                                 by = c("primary_language" = "supported_languages")
                                 )

country_information <- left_join(country_information, netflix_restricted_countries, 
                                 by = c("country" = "netflix_restricted_countries")
                                 )

# Disable scientific notation for values
options(scipen = 999) 


# Replace "NULL" strings with 0 in english_speakers_l1 & convert to numeric
country_information$english_speakers_l1[country_information$english_speakers_l1 == "NULL"] <- 0
country_information$english_speakers_l1 <- as.numeric(country_information$english_speakers_l1)

# Replace "NULL" strings with 0 in english_speakers_l2 & convert to numeric
country_information$english_speakers_l2[country_information$english_speakers_l2 == "NULL"] <- 0
country_information$english_speakers_l2 <- as.numeric(country_information$english_speakers_l2)

# Create English Speakers total as a sum of l1 + l2 columns
country_information$english_speakers_total <- 
  country_information$english_speakers_l1 + country_information$english_speakers_l2

country_information$supported_language_flag <- country_information$supported_language_flag %>%
  replace_na(1)

country_information$netflix_restricted_countries_flag <- country_information$netflix_restricted_countries_flag %>%
  replace_na(1)

country_information
```

Create a Treemap of languages including an 'unsupported_languages' category to demonstrate how much of the overall global market we are missing. 
```{r}

temp_df <- data.frame(primary_language = character(),
                      total_value = numeric())

unsupported_val = (country_information %>%
         filter(supported_language_flag == 1) %>%
         summarize(total_value = sum(population)))$total_value[1]

temp_df <- temp_df %>% add_row(
  primary_language = "Unsupported Languages",
  total_value = unsupported_val)

country_information %>%
  select(country,population,
         primary_language,supported_language_flag) %>%
  filter(supported_language_flag == 0) %>%
  group_by(primary_language) %>%
  summarise(total_value = sum(population, na.rm = TRUE)) %>%
  add_row(temp_df) %>%
  mutate(primary_language = str_to_title(primary_language)) %>%
  group_by(primary_language) %>%
  summarise(total_value = (total_value = sum(round(total_value / 1000000,0)))) %>%
  arrange(desc(total_value)) %>%
  ggplot(aes(area = total_value, fill = primary_language,
               label = paste(primary_language, total_value, 
                             sep = "\n"))) +
    geom_treemap() +
    geom_treemap_text(colour = "white",
                      place = "topleft",
                      size = 15) +
    theme(legend.position = "none") +
    scale_fill_brewer(palette = "Reds") +
    labs(title = "Millions of Speakers...")
```


Remove countries that do not allow Netflix to operate: we assume that these countries will restricted Windmill@Home also. 
```{r}

country_information <- country_information %>%
  filter(netflix_restricted_countries_flag == 1)

```




Add a target_population column which is calculated as follows: 
target_population = 
supported_language_flag * 
((population * primary_language_speakers)  - 
english_speakers_total)

Explanation of calculation: 
Multiply by supported_language_flag: This flag is either 0 or 1. A value of 1 indicates that we do not currently support this language for translation and therefore is a potential market for us. 

population * primary_language_speakers: population is the total population of the country. primary_language_speakers is a ratio of people in that country that speak that language. For example the most commonly spoken language in India is Hindi, however only 44% of Indians actually speak Hindi

- english_speakers_total: We remove all English speakers (both first and second language speakers). English speakers are not part of the population that we are targeting for our translation services. 


Caveats for our target_population calculation: 
We should also be removing French, German, Spanish, Italian & Portuguese speakers from our dataset as Windmill Pictures already has manual translation processes for these markets, but scraping this data from Ethnologue and implenting more RegEx to find these values for each country was not possible in the time we had for this project. 

Secondly Just deducting English speakers from the primary_language_speakers value overestimates the number of English speakers that should be removed: for example in India Ethnologue estimates that there are ~268 million English speakers. Obviously not all of these people Hindi as their first language therefore just deducting English speakers from the primary_language_speakers reduces the size of the market in an unrealistic way. The level of detail required to account for this problem is not available on Ethnologue (or possibly anywhere) so we have had to make do with the calculation laid out above. 

```{r}
country_information$target_population <- 
  round(country_information$supported_language_flag * 
  ((country_information$population * country_information$primary_language_speakers) - 
     country_information$english_speakers_total),0)


# Remove countries with a target population less than a million as these markets are not the right place to start for our service. 
country_information <- country_information %>%
  filter(target_population > 1000000)
                                                   
```


We now want to do the final work to prepare our data to create our market_score. Market Score is a score out of 10 where a country scoring a full 10 points would have the largest population, highest median income & strong 5 year GDP growth:

We then take the 3 parameters and normalise the result from 0 to 1. Finally we apply the following weights to give a final score out of 10: 
average_gdp_change_5_years_norm * 1.5 + 
median_income * 3.5 + 
target_population * 5 + 
= market_score

```{r}

# Simple function to normalise datasets from 0 to 1. I couldn't immediately find
# a function for this in R strangely. 
normalise <- function(x) {
  return((x - min(x, na.rm = TRUE)) / (max(x, na.rm = TRUE) - min(x, na.rm = TRUE)))
}

country_information$median_income_score <-
  normalise(country_information$median_income) * 3.5

country_information$avg_gdp_change_5_years_score <-
  normalise(country_information$avg_gdp_change_5_years) * 1.5

country_information$target_population_score <-
  normalise(country_information$target_population) * 5

country_information$market_score <-
  (country_information$median_income_score + 
     country_information$avg_gdp_change_5_years_score +
     country_information$target_population_score) *
  country_information$supported_language_flag


```





As an alternate to the Market Score Index I am also going to try a K Means Clustering approach: 
```{r}

# Select relevant columns & apply scaling
data <- country_information[, c("median_income", "avg_gdp_change_5_years", "target_population")]
scaled_data <- scale(data)

# Determine the optimal number of clusters using the Elbow Method
set.seed(123)  # For reproducibility
wss <- sapply(1:10, function(k) kmeans(scaled_data, centers = k, nstart = 10)$tot.withinss)

# Plot the Elbow Method graph
plot(1:10, wss, type = "b", pch = 19, frame = FALSE,
     xlab = "Number of Clusters (k)", ylab = "Total Within-Cluster Sum of Squares",
     main = "Elbow Method for Optimal k")

# Perform K-Means clustering with an optimal k (adjust based on the elbow plot)
k <- 4  # Choose based on elbow method
kmeans_result <- kmeans(scaled_data, centers = k, nstart = 25)

# Add cluster labels to the original dataset
country_information$cluster <- as.factor(kmeans_result$cluster)

```



```{r}

# Visualize the clusters in a 2D plot (using the first two principal components)
ggplot(country_information, aes(x = median_income, y = avg_gdp_change_5_years, color = cluster)) +
  geom_point(size = 3) +
  labs(title = "K-Means Clustering of Countries", x = "Median Income", y = "Average GDP Change Previous 5 Years") +
  theme_minimal()
```



```{r}
ggplot(country_information, aes(x = median_income, y = (target_population / 1000000), color = cluster)) +
  geom_point(size = 3) +
  labs(title = "K-Means Clustering of Countries", x = "Median Income", y = "Target Population in Millions (log scale)") +
  theme_minimal() +
  scale_y_log10() # Populations cover 3 orders of magnitude so log scale helps us visualise the data more easily
```

Looking at the results of the clustering we see the groups are defined by the following: 
Cluster 1 - very high populations with strong economic growth, but currently low incomes
Cluster 2 - Varied population (2 million to 55 million), low incomes, and negative growth
Cluster 3 - Varied population (2 million to 251 million), low to moderate incomes & low to high growth
Cluster 4 - Low population (with 1 exception - Japan), high incomes & moderate growth

To help us grasp these clusters more effectively I have given them nicknames: 

Cluster 1 - The big & getting bigger
Cluster 2 - The small & getting smaller
Cluster 3 - The varied middle
Cluster 4 - The overlooked rich


```{r}
# Add names to dataframe:
country_information <- 
  country_information %>% mutate(cluster_name = 
                                 case_when(
                                   cluster == 1 ~ "The big & getting bigger",
                                   cluster == 2 ~ "The small & getting smaller",
                                   cluster == 3 ~ "The varied middle",
                                   cluster == 4 ~ "The overlooked rich"
                                 ))
```


```{r}


tagList(
  tags$h1(
    style = "margin-top: 10px; font-size: 40px;",
    "Cluster 1 - The big & getting bigger"),
  country_information %>% 
    filter(cluster == 1) %>%
    select(country, target_population, avg_gdp_change_5_years, median_income) %>%
    mutate(avg_gdp_change_5_years = round(avg_gdp_change_5_years, 1),
           target_population = round(target_population / 1000000, 1),
           median_income = round(median_income, 0)) %>%
    arrange(desc(target_population)) %>%
    rename(Country = country,
           "Target Population (millions)" = target_population,
           "Average GDP Change (5 Years)" = avg_gdp_change_5_years,
           "Median Income" = median_income) %>%
    datatable(
      options = list(pageLength = 5, autoWidth = TRUE)
    ) %>%
    formatStyle(
      'Target Population (millions)',
      backgroundSize = '100% 100%',
      backgroundRepeat = 'no-repeat',
      backgroundPosition = 'center'
    ),
  
  tags$p(
    style = "margin-top: 10px; font-size: 14px;",
    HTML("
    The Big & Getting Bigger cluster is defined by having only 2 countries that both have massive populations: India & Indonesia. India's population is smaller than you would expect as we are only focusing on the Hindi speaking population. Both countries have low incomes, but with very strong growth. <br/>
    <br/>

Pros: large population of middle class consumers even when we account for the low median income. In addition because of these country's strong growth we should expect them to add millions of consumers each year that are now able to afford streaming services.<br/>
<br/>
Cons: low median income"
  ))
)


```

```{r}
tagList(
  tags$h1(
    style = "margin-top: 10px; font-size: 40px;",
    "Cluster 2 - The Small & Getting Smaller"),
  country_information %>% 
    filter(cluster == 2) %>%
    select(country, target_population, avg_gdp_change_5_years, median_income) %>%
    mutate(avg_gdp_change_5_years = round(avg_gdp_change_5_years, 1),
           target_population = round(target_population / 1000000, 1),
           median_income = round(median_income, 0)) %>%
    arrange(desc(target_population)) %>%
    rename(Country = country,
           "Target Population (millions)" = target_population,
           "Average GDP Change (5 Years)" = avg_gdp_change_5_years,
           "Median Income" = median_income) %>%
    datatable(
      options = list(pageLength = 5, autoWidth = TRUE)
    ) %>%
    formatStyle(
      'Target Population (millions)',
      backgroundSize = '100% 100%',
      backgroundRepeat = 'no-repeat',
      backgroundPosition = 'center'
    ),
  
  tags$p(
    style = "margin-top: 10px; font-size: 14px;",
    HTML("
        The Small & Getting Smaller cluster is defined by having shrinking incomes.<br/>
        <br/>
        Pros: Some countries have large populations.<br/>
        <br/>
        Cons: Generally low incomes and in all cases those incomes are shrinking. Many of these countries are defined by internal or international conflict.
    ")
)



)
```

```{r}
tagList(
  tags$h1(
    style = "margin-top: 10px; font-size: 40px;",
    "Cluster 3 - The Varied Middle"),
  country_information %>% 
    filter(cluster == 3) %>%
    select(country, target_population, avg_gdp_change_5_years, median_income) %>%
    mutate(avg_gdp_change_5_years = round(avg_gdp_change_5_years, 1),
           target_population = round(target_population / 1000000, 1),
           median_income = round(median_income, 0)) %>%
    arrange(desc(target_population)) %>%
    rename(Country = country,
           "Target Population (millions)" = target_population,
           "Average GDP Change (5 Years)" = avg_gdp_change_5_years,
           "Median Income" = median_income) %>%
    datatable(
      options = list(pageLength = 5, autoWidth = TRUE)
    ) %>%
    formatStyle(
      'Target Population (millions)',
      backgroundSize = '100% 100%',
      backgroundRepeat = 'no-repeat',
      backgroundPosition = 'center'
    ),
  
  tags$p(
    style = "margin-top: 10px; font-size: 14px;",
    HTML("
        The Varied Middle Cluster is difficult to easily define, it features countries with large populations and low incomes (e.g. Pakistan) and small populations with high incomes (e.g. Lithuania). Overall this segment is too varied to treat as a sensible group. A separate piece of analysis on this group individually is probably the best approach if we look at this group in particular.<br/>
        <br/>
        Pros: very varied with several opportunities buried within the group. In particular if we were to treat all the Arabic speaking countries as a single market they would likely be grouped with the Big & Getting Bigger cluster..<br/>
        <br/>
        Cons: too diverse to treat as a single unit and to approach with a single strategy.
    ")
)
)
```


```{r}
tagList(
  tags$h1(
    style = "margin-top: 10px; font-size: 40px;",
    "Cluster 3 - The Overlooked Rich"),
  country_information %>% 
    filter(cluster == 4) %>%
    select(country, target_population, avg_gdp_change_5_years, median_income) %>%
    mutate(avg_gdp_change_5_years = round(avg_gdp_change_5_years, 1),
           target_population = round(target_population / 1000000, 1),
           median_income = round(median_income, 0)) %>%
    arrange(desc(target_population)) %>%
    rename(Country = country,
           "Target Population (millions)" = target_population,
           "Average GDP Change (5 Years)" = avg_gdp_change_5_years,
           "Median Income" = median_income) %>%
    datatable(
      options = list(pageLength = 5, autoWidth = TRUE)
    ) %>%
    formatStyle(
      'Target Population (millions)',
      backgroundSize = '100% 100%',
      backgroundRepeat = 'no-repeat',
      backgroundPosition = 'center'
    ),
  
  tags$p(
    style = "margin-top: 10px; font-size: 14px;",
    HTML("
        The Overlooked Rich cluster is defined by countries that have high median incomes, but do not speak one of our core translation languages (English, Portuguese, Spanish, German, Italian). Japan makes up 94% of the population of this cluster. <br/>
        <br/>
        Pros: High incomes with reasonable GDP growth and already well established media markets.<br/>
        <br/>
        Cons: Other than Japan this cluster is made up of very small population countries.
    ")
)
)
```



Nicely formatted datatable with market_score: 
```{r}
country_information %>%
  select(country,primary_language,market_score) %>%
  mutate(market_score = round(country_information$market_score,1)) %>%
  filter(market_score > 0) %>%
  arrange(desc(market_score)) %>%
  datatable(options = list(pageLength = 5, autoWidth = TRUE)) %>%
  formatStyle(
    'market_score',
    background = styleColorBar(country_information$market_score, 'red'),
    backgroundSize = '100% 100%',
    backgroundRepeat = 'no-repeat',
    backgroundPosition = 'center'
  )
```

Raw scores table: 
```{r}

country_information %>%
  select(country,population, primary_language_speakers,english_speakers_total,median_income,avg_gdp_change_5_years,market_score) %>%
  mutate(market_score = round(country_information$market_score,1)) %>%
  filter(market_score > 0) %>%
  arrange(desc(market_score)) %>%
  datatable(options = list(pageLength = 5, autoWidth = TRUE)) %>%
  formatStyle(
    'market_score',
    background = styleColorBar(country_information$market_score, 'red'),
    backgroundSize = '100% 100%',
    backgroundRepeat = 'no-repeat',
    backgroundPosition = 'center'
  )


```



Composite scores table
```{r}
country_information %>%
  select(country,median_income_score, target_population_score ,english_speakers_total,avg_gdp_change_5_years_score,market_score) %>%
  mutate(market_score = round(country_information$market_score,1)) %>%
  filter(market_score > 0) %>%
  arrange(desc(market_score)) %>%
  datatable(options = list(pageLength = 5, autoWidth = TRUE)) %>%
  formatStyle(
    'market_score',
    background = styleColorBar(country_information$market_score, 'red'),
    backgroundSize = '100% 100%',
    backgroundRepeat = 'no-repeat',
    backgroundPosition = 'center'
  )
```


Create the market_score.csv file based on country_information.csv with all of the necessary processing completed in line with requirements for the dashboard we are going to create. 

```{r}

data <- country_information %>%
  select(-supported_language_flag,-cluster,-netflix_restricted_countries_flag)


# Rename columns
colnames(data) <- c("Country", "Population (millions)", "Native English Speakers (millions)", 
                    "Second Language English Speakers (millions)", "Median Income ($)", 
                    "5 Year Average GDP Change %", "Most Commonly Spoken Language", 
                    "Ratio of Speakers of Most Common Language", "English Speakers Total (millions)", 
                    "Median Income Score", "Average GDP Change Score", "Target Population Score", "Market Score",
                    "Target Population (millions)","Cluster Name")

# Convert Population to millions and rename column
data <- data %>%
  mutate(`Population (millions)` = round(`Population (millions)` / 1e6, 1),
         `Native English Speakers (millions)` = round(`Native English Speakers (millions)` / 1e6,1),
         `Second Language English Speakers (millions)` = round(`Second Language English Speakers (millions)` / 1e6,1),
         `English Speakers Total (millions)` = round(`English Speakers Total (millions)` / 1e6,1),
         `Target Population (millions)` = round(`Target Population (millions)` / 1e6,1),
         `Median Income Score` = round(`Median Income Score`, 1),
         `Average GDP Change Score` = round(`Average GDP Change Score`, 1),
         `Target Population Score` = round(`Target Population Score`, 1),
         `Market Score` = round(`Market Score`, 1),
         `Median Income ($)` = round(`Median Income ($)`, 0),
         `5 Year Average GDP Change %` = round(`5 Year Average GDP Change %`, 2),
         `Target Population (millions)` = round(`Target Population (millions)`, 1))

write.csv(data,"C:/Users/lordryan/Documents/GitHub/windmill_mov_subtitles/market_score.csv")


```

